#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>

//Defining Pi
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

using std::cout;
using std::endl;
using std::vector;
using std::ofstream;

//Random Number Tools
double uniform01() {
    return (double)rand() / (RAND_MAX + 1.0);
}

// Normal distribution 
double normal(double mean, double stddev) {
    double sum = 0.0;
    for (int i = 0; i < 12; i++)
        sum += uniform01();
    sum -= 6.0;   // zero mean
    return mean + stddev * sum;
}


//Data Structures
struct State {
    double x, y;
    double vx, vy;
};

struct RocketParams {
    double mass;
    double thrust;
    double burnTime;
    double Cd;
    double area;
    double launchAngle;
};


//Rocket Dynamics
State derivatives(const State& s, const RocketParams& p, double t) {
    const double g   = 9.81;
    const double rho = 1.225;

    double v = sqrt(s.vx*s.vx + s.vy*s.vy);

    // Aerodynamic drag
    double Dx = -0.5 * rho * p.Cd * p.area * v * s.vx;
    double Dy = -0.5 * rho * p.Cd * p.area * v * s.vy;

    // Fixed thrust direction during burn
    double Tx = 0.0;
    double Ty = 0.0;

    if (t < p.burnTime) {
        Tx = p.thrust * cos(p.launchAngle);
        Ty = p.thrust * sin(p.launchAngle);
    }

    return {
        s.vx,
        s.vy,
        (Tx + Dx) / p.mass,
        (Ty + Dy) / p.mass - g
    };
}

//RK4 Integration, Numerical Solver
State rk4(const State &s, const RocketParams &p, double t, double dt) {
    State k1 = derivatives(s, p, t);

    State s2 = { s.x + 0.5*dt*k1.x,  s.y + 0.5*dt*k1.y,
                 s.vx + 0.5*dt*k1.vx, s.vy + 0.5*dt*k1.vy };
    State k2 = derivatives(s2, p, t + 0.5*dt);

    State s3 = { s.x + 0.5*dt*k2.x,  s.y + 0.5*dt*k2.y,
                 s.vx + 0.5*dt*k2.vx, s.vy + 0.5*dt*k2.vy };
    State k3 = derivatives(s3, p, t + 0.5*dt);

    State s4 = { s.x + dt*k3.x,  s.y + dt*k3.y,
                 s.vx + dt*k3.vx, s.vy + dt*k3.vy };
    State k4 = derivatives(s4, p, t + dt);

    return {
        s.x  + dt/6.0*(k1.x  + 2*k2.x  + 2*k3.x  + k4.x),
        s.y  + dt/6.0*(k1.y  + 2*k2.y  + 2*k3.y  + k4.y),
        s.vx + dt/6.0*(k1.vx + 2*k2.vx + 2*k3.vx + k4.vx),
        s.vy + dt/6.0*(k1.vy + 2*k2.vy + 2*k3.vy + k4.vy)
    };
}


//Single Flight Simulation
void simulateFlight(const RocketParams &p, double &range, double &apogee) {
    State s = {0.0, 0.0, 0.0, 0.0};

    double t  = 0.0;
    double dt = 0.01;
    apogee = 0.0;

    while (s.y >= 0.0 && t < 200.0) {
        s = rk4(s, p, t, dt);
        t += dt;
        if (s.y > apogee)
            apogee = s.y;
    }

    range = s.x;
}


//Monte Carlo Driver Main
int main() {
    srand(time(NULL));

    //Runs
    const int N = 2000;
    vector<double> ranges;
    vector<double> apogees;

    ofstream csv("dispersion.csv");
    csv << "run,range,apogee\n";

    for (int i = 0; i < N; i++) {
    RocketParams p;

    // Decompose mass
    double m_dry  = normal(10.0, 0.2);
    double m_prop = normal(5.0, 0.15);
    p.mass = m_dry + m_prop;

    // Burn time with uncertainty
    p.burnTime = normal(2.5, 0.1);

    // Physics-based thrust
    double ve   = normal(2200.0, 50.0);        // exhaust velocity (m/s)
    double mdot = m_prop / p.burnTime;
    p.thrust    = mdot * ve;

    // Aerodynamics
    p.Cd   = normal(0.75, 0.05);
    p.area = 0.03;

    p.launchAngle = normal(88.0 * M_PI / 180.0,
                            1.0 * M_PI / 180.0);

    double range, apogee;
    simulateFlight(p, range, apogee);

    ranges.push_back(range);
    apogees.push_back(apogee);
    csv << i << "," << range << "," << apogee << "\n";
}


    // Statistics
    double mean = 0.0;
    for (double r : ranges) mean += r;
    mean /= N;

    double var = 0.0;
    for (double r : ranges)
        var += (r - mean)*(r - mean);
    var /= N;

    double meanA = 0.0;
    for (double a : apogees) meanA += a;
    meanA /= N;
    
    double varA = 0.0;
    for (double a : apogees)
    varA += (a - meanA)*(a - meanA);
    varA /= N;

    //Printing Results
    cout << "Monte Carlo Runs: " << N << endl;
    cout << "Mean Range: " << mean << " m" << endl;
    cout << "Std Dev Range: " << sqrt(var) << " m" << endl;
    cout << "Mean Apogee (Altitude): " << meanA << " m" << endl;
    cout << "Std Dev Apogee: " << sqrt(varA) << " m" << endl;
    cout << "CSV written to dispersion.csv" << endl;

    return 0;
}

